m4_divert(0)dnl
# Setup

    - CM.make "test.cm";
    ...
    val it = true : bool
    - fun parse fileName = (UXML.parseDocument TextIO.StreamIO.input1 ((TextIO.getInstream o TextIO.openIn) fileName); true);
    ...
    val parse = fn : string -> bool
    - fun readFile fileName = let val ins = TextIO.openIn fileName in TextIO.inputAll ins before TextIO.closeIn ins end;
    ...
    val readFile = fn : string -> TextIO.vector
    - fun assert actual expected = actual = expected orelse (print ("expected: " ^ expected ^ ", but got: " ^ actual ^ "\n"); false);
    val assert = fn : string -> string -> bool

# Parse valid stand-alone documents

m4_for([num], [1], [110], [1], [
m4_bmatch(num,
   [49], [## 049 is skipped because of UTF-16
], [50], [## 050 is skipped because of UTF-16
], [51], [## 051 is skipped because of UTF-16
], [52], [## 052 is skipped because of a unicode char >= $#x10000;
], [[##] xmlconf/xmltest/valid/sa/m4_format([%03d], num).xml

    - parse "xmlconf/xmltest/valid/sa/m4_format([%03d], num).xml";
    val it = true : bool

])])

# Write documents as Canonical XML

m4_for([num], [1], [110], [1], [
m4_bmatch(num,
   [49], [## 049 is skipped because of UTF-16
], [50], [## 050 is skipped because of UTF-16
], [51], [## 051 is skipped because of UTF-16
], [52], [## 052 is skipped because of a unicode char >= $#x10000;
], [69], [## 069.xml is skipped because of NOTATION
], [76], [## 076.xml is skipped because of NOTATION
], [89], [## 089.xml is skipped because of a unicode char >= $#x10000;
], [90], [## 090.xml is skipped because of NOTATION
], [91], [## 091.xml is skipped because of NOTATION
], [[##] xmlconf/xmltest/valid/sa/m4_format([%03d], num).xml

    - assert ((UXML.toCanon o UXML.parseFile) "xmlconf/xmltest/valid/sa/m4_format([%03d], num).xml") (readFile "xmlconf/xmltest/valid/sa/out/m4_format([%03d], num).xml");
    val it = true : bool

])])

