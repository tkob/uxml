token S ;
token LXMLDECL ;
token RXMLDECL ;
token LDOCTYPE ;
token XMLAPOS ;
token XMLQUOT ;
token XMLATTVALUE of string ;
token XMLCHARS of string ;
token XMLCDSECT of string ;
token XMLNAME of string ;
token XMLENTITYREF of string ;
token LSTAG of string ;
token RTAG ;
token REMPTYTAG ;
token LETAG of string ;
token LXMLCOMMENT ;
token RXMLCOMMENT ;
token LPI of string ;
token RPI ;
token LBRACKET ;
token RBRACKET ;
token LELEMENTDECL ;
token LATTLISTDECL ;
token LENTITYDECL ;
token LNOTATIONDECL ;
token LPAREN ;
token RPAREN ;
token BAR ;
token QUESTION ;
token STAR ;
token PLUS ;
token COMMA ;
token EQUAL ;

-- [1] document ::= prolog element Misc*
Document. Document ::= Prolog Element [Misc] ;

-- [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
EmptyComment. Comment ::= LXMLCOMMENT RXMLCOMMENT ;
Comment.      Comment ::= LXMLCOMMENT XMLCHARS RXMLCOMMENT ;

-- [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
EmptyPI. PI ::= LPI RPI ;
PI.      PI ::= LPI [Chars] RPI ;

-- [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?
-- Note: ALthough this rule allows at most one occurence of doctypedecl,
--       we regard doctypedecl as a Misc to simplify syntax.
Prolog1. Prolog ::= [Misc] ;
Prolog2. Prolog ::= XMLDecl [Misc] ;

-- [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
-- [24] VersionInfo ::= S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')
-- [25] Eq ::= S? '=' S?
-- [26] VersionNum ::= '1.' [0-9]+

-- [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'
-- TODO: ExternalID
Doctypedecl1. Doctypedecl ::= LDOCTYPE XMLNAME RTAG ;
Doctypedecl2. Doctypedecl ::= LDOCTYPE XMLNAME LBRACKET [IntSubset] RBRACKET RTAG ;

-- [28a] DeclSep ::= PEReference | S
-- [28b] intSubset ::= (markupdecl | DeclSep)*
-- [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment
-- TODO: DeclSep. IntSubset ::= ...
-- TODO: PI. IntSubset ::= ...
-- TODO: Comment. IntSubset ::= ...
-- TODO: EntityDecl. IntSubset ::= ...
-- TODO: NotationDecl. IntSubset ::= ...
ElementdeclIntSubset. IntSubset ::= Elementdecl ;
AttlistDeclIntSubset. IntSubset ::= AttlistDecl ;
separator IntSubset "" ;

-- [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"'))
-- [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )
-- [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
XMLDecl. XMLDecl ::= LXMLDECL [PseudoAttr] RXMLDECL ;
PseudoAttr1. PseudoAttr ::= XMLNAME EQUAL XMLAPOS XMLCHARS XMLAPOS ;
PseudoAttr2. PseudoAttr ::= XMLNAME EQUAL XMLQUOT XMLCHARS XMLQUOT ;
separator PseudoAttr "" ;

-- [27] Misc ::= Comment | PI | S
-- TODO
CommetnMisc. Misc ::= Comment ;
PIMisc.      Misc ::= PI ;
SMisc.       Misc ::= XMLCHARS ;
DoctypeMisc. Misc ::= Doctypedecl ;
separator Misc "" ;

-- [39] element ::= EmptyElemTag | STag content ETag
EmptyElement. Element ::= EmptyElemTag ;
Element.      Element ::= Stag [Content] ETag ;

-- [40] STag ::= '<' Name (S Attribute)* S? '>'
Stag. Stag ::= LSTAG [Attribute] RTAG ;

-- [41] Attribute ::= Name Eq AttValue
Attribute. Attribute ::= XMLNAME EQUAL XMLATTVALUE ;
separator Attribute "" ;

-- [42] ETag ::= '</' Name S? '>'
ETag. ETag ::= LETAG RTAG ;

-- [43] content ::= CharData? ((element | Reference | CDSect | PI | Comment) CharData?)*
CharDataContent.  Content ::= Chars ;
ElementContent.   Content ::= Element ;
ReferenceContent. Content ::= XMLENTITYREF ;
CDSectContent.    Content ::= XMLCDSECT ;
PIContent.        Content ::= PI ;
CommentContent.   Content ::= Comment ;
separator Content "" ;

-- [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '/>'
EmptyElemTag. EmptyElemTag ::= LSTAG [Attribute] REMPTYTAG ;

-- [45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'
Elementdecl. Elementdecl ::= LELEMENTDECL XMLNAME [Contentspec] RTAG ;

-- [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children
-- Don't parse internal structure of elementdecl
XmlnameContentspec. Contentspec ::= XMLNAME ;
LparenContentspec. Contentspec ::= LPAREN ;
RparenContentspec. Contentspec ::= RPAREN ;
BarContentspec. Contentspec ::= BAR ;
QuestionContentspec. Contentspec ::= QUESTION ;
StarContentspec. Contentspec ::= STAR ;
PlusContentspec. Contentspec ::= PLUS ;
CommaContentspec. Contentspec ::= COMMA ;
separator Contentspec "" ;

-- [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'
-- [53] AttDef ::= S Name S AttType S DefaultDecl
-- [54] AttType ::= StringType | TokenizedType | EnumeratedType
-- [55] StringType ::= 'CDATA'
-- [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'
-- [57] EnumeratedType ::= NotationType | Enumeration
-- [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'
-- [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'
-- [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)
AttlistDecl. AttlistDecl ::= LATTLISTDECL XMLNAME [AttDef] RTAG ;
-- Don't parse internal structure of AttlistDecl
XmlnameAttDef. AttDef ::= XMLNAME ;
LparenAttDef. AttDef ::= LPAREN ;
RparenAttDef. AttDef ::= RPAREN ;
BarAttDef. AttDef ::= BAR ;
XmlcharsAttDef. AttDef ::= XMLCHARS ;
separator AttDef "" ;

Chars. Chars ::= XMLCHARS ;
separator nonempty Chars "" ;
